/*
 * AUTHOR: Vatsav Sethupathi
 * FILE: MyHashMap.java
 * ASSIGNMENT: Programming Assignment 8 - Generic HashMap
 * COURSE: CSc 210 Spring 2020
 * PURPOSE: This file contains a representation of the MyHashMap class which is supposed to
 *          behave like the pre-built HashMap class that is offered by JAVA. This maps one 
 *          Generic object (the key) to another (the value). The keys and values are stored
 *          in an ArrayList of HashNodes. The runtime complexities of most of the functions
 *          of this data structure is O(1), meaning that this structure is quite efficient.
 *          The number of buckets, or partitions in the HashMap in this case is 8
 */

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;


public class MyHashMap<K,V> {
	// This is the default number of buckets in the map
	static final int NUM_BUCKETS = 8;
	
	private List<HashNode<K, V>> array;  // The primary structure that holds all the data values
	private int size[];  // Keeps track of the size of each bucket
	private int totalSize;  // Keeps track of the total number of data values
	private Set<K> keySet;
	private Set<V> valueSet;
	
	/**
	 * This is the default, no parameter constructor for the MyHashMap class
	 * which constructs a MyHashMap with 8 buckets
	 * 
	 * @param None
	 */
	public MyHashMap() {
		array = new ArrayList<HashNode<K,V>>(NUM_BUCKETS);
		size = new int[NUM_BUCKETS];
		
		// This has a runtime complexity of O(1) since the number of buckets is constant
		for(int i = 0; i < NUM_BUCKETS; i++) {
			array.add(null);
			size[i] = 0;
		}
		
		totalSize = 0;
		keySet = new HashSet<K>();
		valueSet = new HashSet<V>();
	}
	
	/**
	 * Clears the structure of all of the Key-value mappings
	 */
	public void clear() {
		array = new ArrayList<HashNode<K,V>>(NUM_BUCKETS);
		totalSize = 0;
		size = new int[8];
		
		// This has a runtime complexity of O(1) since the number of buckets is constant
		for(int i = 0; i < NUM_BUCKETS; i++) {
			array.add(null);
			size[i] = 0;
		}
		
		keySet = new HashSet<K>();
		valueSet = new HashSet<V>();
	}
	
	/**
	 * Returns true if the structure contains a mapping where the key
	 * is equal to the parameter passed in
	 * 
	 * @param key the key to be found in the map
	 * @return true if the key is present or false if it is not
	 */
	public boolean containsKey(K key) {
		return keySet.contains(key);
	}
	
	/**
	 * Returns true if the structure contains a mapping where the value
	 * is equal to the parameter passed in
	 * 
	 * @param value the value to be found in the map
	 * @return true if the value is present or false if it is not
	 */
	public boolean containsValue(V value) {
		return valueSet.contains(value);
	}
	
	/**
	 * Returns a value in the map which is mapped to the key that is
	 * passed in as the parameter. If the key is not present in the 
	 * map, the function returns null
	 * 
	 * @param key the key that is associated with the required value
	 * 
	 * @return The value that is mapped to the passed in key, or null
	 * if it is not present
	 */
	public V get(K key) {
		if(!keySet.contains(key))
			return null;
		
		int index = hash(key);
		HashNode<K,V> curr = array.get(index);
		
		while(curr != null) {
			if(curr.getKey().equals(key))
				return curr.getValue();
			curr = curr.getNext();
		}
		
		return null;
	}
	
	
	/**
	 * Return true if there are no mappings in the structure
	 * or false if there are elements present
	 * 
	 * @return boolean representing whether the structure is empty
	 */
	public boolean isEmpty() {
		return totalSize == 0;
	}
	
	
	/**
	 * This returns a set of the keys of all the key-value mappings
	 * present in the map. The order of the keys is arbitrary
	 * 
	 * @return keySet A set of all the keys in the structure
	 */
	public Set<K> keySet(){
		return keySet;
	}
	
	/**
	 * This method adds the given key value mapping into the structure
	 * based on the hashCode generated by the key. If the key already 
	 * exists, the key value mapping is replaced using the given value.
	 * 
	 * @param key the key that is associated with the value
	 * @param value the value that is to be stored in the map
	 * 
	 * @return The previous mapping of the key if applicable, 
	 * otherwise null
	 */
	public V put(K key, V value) {
		int index = hash(key);
		V retval = null;
		
		if(keySet.contains(key)) {
			retval = get(key);
			valueSet.remove(retval);
			HashNode<K,V> curr = array.get(index);
			
			while(curr != null) {
				
				if(curr.getKey().equals(key)) {
					curr.setValue(value);
					valueSet.add(value);
					break;
				}
				curr = curr.getNext();
				
			}
		}
		else {
			HashNode<K,V> newFront = new HashNode<>(key, value);
			newFront.setNext(array.get(index));
			array.set(index, newFront);
			keySet.add(key);
			valueSet.add(value);
			size[index]++;
			totalSize++;
		}
		
		return retval;
	}
	
	/**
	 * This function returns a specific key-value mapping from the
	 * map, based on the key that is passed in and returns the value
	 * associated with the key. If the key is not present in the map,
	 * null is returned
	 * 
	 * @param key the key of the mapping that is to be removed
	 * 
	 * @return The value mapped to the key that was removed, or 
	 * null if the key is not present
	 */
	public V remove(K key) {
		if(keySet.contains(key)) {
			V retval = get(key);
			keySet.remove(key);
			valueSet.remove(retval);
			int index = hash(key);
			size[index]--;
			totalSize--;
			HashNode<K,V> curr = array.get(index);
			
			if(curr.getKey().equals(key))
				array.set(index, curr.getNext());
			
			else {
				
				while(curr.getNext() != null) {
					if(curr.getNext().getKey().equals(key)) {
						curr.setNext(curr.getNext().getNext());
						break;
					}
					curr = curr.getNext();
				}
				
			}
			
			return retval;
		}
		
		// This means that the map doesn't have the key that was passed in
		return null;
	}
	
	/**
	 * Returns the number of key-value mappings in the structure
	 * 
	 * @return the size
	 */
	public int size() {
		return totalSize;
	}
	
	public void printTable() {
		int totalConflicts = 0;
		
		for(int i = 0; i < NUM_BUCKETS; i++) {
			
			System.out.print("Index " + i + ": ");
			System.out.print("(" + (size[i] > 0 ? (size[i] - 1) : (size[i])) + " conflicts), [");
			
			if(array.get(i) != null) {
				HashNode<K,V> curr = array.get(i);
				while(curr != null) {
					System.out.print(curr.getKey() + ", ");
					curr = curr.getNext();
				}
			}
			
			System.out.println("]");
			// The ternary operator is used so as to keep the number of conflicts >= 0
			totalConflicts += (size[i] > 0 ? (size[i] - 1) : (size[i]));
		}
		
		System.out.println("Total # of conflicts: " + totalConflicts + "\n");
	}
	
	/**
	 * This method is the default hash code implementation that was
	 * provided as a part of the PA spec
	 * 
	 * @param key the key whose hashCode is to be found
	 * 
	 * @return The hash value of the key that is passed in
	 */
	private int hash(K key) {
		int hashCode = key.hashCode();
		int index = hashCode % NUM_BUCKETS;
		return Math.abs(index);
	}
	
}
